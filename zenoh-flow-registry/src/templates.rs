//
// Copyright (c) 2017, 2021 ADLINK Technology Inc.
//
// This program and the accompanying materials are made available under the
// terms of the Eclipse Public License 2.0 which is available at
// http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
// which is available at https://www.apache.org/licenses/LICENSE-2.0.
//
// SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
//
// Contributors:
//   ADLINK zenoh team, <zenoh@adlink-labs.tech>
//

use crate::{CZFError, CZFResult};
use serde::Serialize;
use tinytemplate::TinyTemplate;

static OP_TEMPLATE: &str = r#"
use zenoh_flow::async_std::sync::Arc;
use std::collections::HashMap;
use zenoh_flow::zenoh_flow_derive::ZFState;
use zenoh_flow::\{
    default_input_rule, default_output_rule, downcast_mut, get_input, zf_data, ZFComponent,
    ZFComponentInputRule, ZFComponentOutput, ZFComponentOutputRule, ZFDataTrait, ZFOperatorTrait,
    ZFResult, ZFStateTrait,
};

#[derive(Debug)]
struct {name};


impl ZFOperatorTrait for {name} \{
    fn run(
        &self,
        _context: &mut zenoh_flow::ZFContext,
        dyn_state: &mut Box<dyn zenoh_flow::ZFStateTrait>,
        inputs: &mut HashMap<String, zenoh_flow::runtime::message::ZFDataMessage>,
    ) -> zenoh_flow::ZFResult<HashMap<zenoh_flow::ZFPortID, Arc<dyn ZFDataTrait>>> \{
        todo!()
    }
}

impl ZFComponentInputRule for {name} \{
    fn input_rule(
        &self,
        _context: &mut zenoh_flow::ZFContext,
        state: &mut Box<dyn zenoh_flow::ZFStateTrait>,
        tokens: &mut HashMap<String, zenoh_flow::Token>,
    ) -> zenoh_flow::ZFResult<bool> \{
        default_input_rule(state, tokens)
    }
}

impl ZFComponentOutputRule for {name} \{
    fn output_rule(
        &self,
        _context: &mut zenoh_flow::ZFContext,
        state: &mut Box<dyn zenoh_flow::ZFStateTrait>,
        outputs: &HashMap<String, Arc<dyn ZFDataTrait>>,
    ) -> zenoh_flow::ZFResult<HashMap<zenoh_flow::ZFPortID, ZFComponentOutput>> \{
        default_output_rule(state, outputs)
    }
}

impl ZFComponent for {name} \{
    fn initialize(
        &self,
        _configuration: &Option<HashMap<String, String>>,
    ) -> Box<dyn zenoh_flow::ZFStateTrait> \{
        zenoh_flow::zf_empty_state!()
    }

    fn clean(&self, _state: &mut Box<dyn ZFStateTrait>) -> ZFResult<()> \{
        Ok(())
    }
}

// Also generated by macro
zenoh_flow::export_operator!(register);

fn register() -> ZFResult<Arc<dyn ZFOperatorTrait>> \{
    Ok(Arc::new({name}) as Arc<dyn ZFOperatorTrait>)
}

"#;

#[derive(Serialize)]
struct OperatorContext {
    name: String,
}

fn some_kind_of_uppercase_first_letter(s: &str) -> String {
    let mut c = s.chars();
    match c.next() {
        None => String::new(),
        Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
    }
}

pub fn operator_template(name: String) -> CZFResult<String> {
    let mut tt = TinyTemplate::new();
    tt.add_template("operator", OP_TEMPLATE)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))?;

    let ctx = OperatorContext {
        name: some_kind_of_uppercase_first_letter(&name),
    };

    tt.render("operator", &ctx)
        .map_err(|e| CZFError::GenericError(format!("{}", e)))
}
